<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Binary Black Hole Merger</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: radial-gradient(circle at 20% 20%, #0b0b16, #020206 60%, #000);
      color: #e8e8f5;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      min-height: 100vh;
      overflow: hidden;
    }

    header {
      position: absolute;
      top: 24px;
      left: 24px;
      z-index: 2;
      max-width: 360px;
    }

    header h1 {
      font-size: 1.5rem;
      letter-spacing: 0.02em;
      margin-bottom: 0.5rem;
    }

    header p {
      font-size: 0.9rem;
      line-height: 1.4;
      color: #b5b5d6;
    }

    #canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }

    .legend {
      position: absolute;
      bottom: 24px;
      left: 24px;
      color: #9fa7ff;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <header>
    <h1>Binary Black Hole In-spiral</h1>
    <p>
      The orbit follows Keplerian motion while the separation shrinks according to the
      Peters-Mathews gravitational-wave energy loss formula. Accretion tracers respond
      to the changing spacetime as the horizons tighten their dance.
    </p>
  </header>
  <canvas id="canvas"></canvas>
  <div class="legend">Kepler + Peters-Mathews GW inspiral (scaled)</div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const state = {
      width: window.innerWidth,
      height: window.innerHeight,
      time: 0,
      lastTimestamp: 0,
    };

    const constants = {
      G: 6.6743e-11,
      c: 299_792_458,
      solarMass: 1.98847e30,
    };

    const system = {
      m1: 36 * constants.solarMass,
      m2: 29 * constants.solarMass,
      separation: 2.25e9,
      theta: 0,
    };

    const timeScale = 1400;
    const metersPerPixel = system.separation / 280;

    const blackHoles = [
      {
        mass: system.m1,
        position: { x: -system.separation / 2, y: 0 },
        radius: 1,
        color: "#0b0b0f",
      },
      {
        mass: system.m2,
        position: { x: system.separation / 2, y: 0 },
        radius: 1,
        color: "#09090c",
      },
    ];

    const particleCount = 1000;
    const particles = Array.from({ length: particleCount }, () => createParticle());

    function resize() {
      state.width = window.innerWidth;
      state.height = window.innerHeight;
      canvas.width = state.width * devicePixelRatio;
      canvas.height = state.height * devicePixelRatio;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }

    function createParticle() {
      const angle = Math.random() * Math.PI * 2;
      const radius = system.separation * (0.7 + Math.random() * 1.4);
      const orbitSpeed = Math.sqrt((constants.G * (system.m1 + system.m2)) / radius);
      return {
        position: {
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius,
        },
        velocity: {
          x: -Math.sin(angle) * orbitSpeed,
          y: Math.cos(angle) * orbitSpeed,
        },
        hue: 210 + Math.random() * 40,
        life: 1,
      };
    }

    function resetParticle(particle) {
      Object.assign(particle, createParticle());
    }

    function computeSchwarzschildRadius(mass) {
      return (2 * constants.G * mass) / (constants.c ** 2);
    }

    function updateBinary(dt) {
      const totalMass = system.m1 + system.m2;
      const separation = Math.max(system.separation, computeSchwarzschildRadius(totalMass) * 12);
      const omega = Math.sqrt((constants.G * totalMass) / (separation ** 3));
      const daDt =
        (-64 / 5) *
        (constants.G ** 3 * system.m1 * system.m2 * totalMass) /
        (constants.c ** 5 * separation ** 3);

      system.theta += omega * dt * timeScale;
      system.separation = Math.max(separation + daDt * dt * timeScale, separation * 0.92);

      const r1 = (system.m2 / totalMass) * system.separation;
      const r2 = (system.m1 / totalMass) * system.separation;

      blackHoles[0].position.x = Math.cos(system.theta) * -r1;
      blackHoles[0].position.y = Math.sin(system.theta) * -r1;
      blackHoles[1].position.x = Math.cos(system.theta) * r2;
      blackHoles[1].position.y = Math.sin(system.theta) * r2;

      blackHoles[0].radius = Math.max(10, computeSchwarzschildRadius(system.m1) / metersPerPixel);
      blackHoles[1].radius = Math.max(8, computeSchwarzschildRadius(system.m2) / metersPerPixel);
    }

    function integrateParticles(dt) {
      particles.forEach((particle) => {
        let ax = 0;
        let ay = 0;
        blackHoles.forEach((hole) => {
          const dx = hole.position.x - particle.position.x;
          const dy = hole.position.y - particle.position.y;
          const distanceSq = dx * dx + dy * dy + 1;
          const distance = Math.sqrt(distanceSq);
          const pull = (constants.G * hole.mass) / distanceSq;
          ax += (pull * dx) / distance;
          ay += (pull * dy) / distance;

          if (distance < hole.radius * metersPerPixel * 0.9) {
            particle.life -= 0.3;
          }
        });

        particle.velocity.x += ax * dt * timeScale;
        particle.velocity.y += ay * dt * timeScale;
        particle.velocity.x *= 0.995;
        particle.velocity.y *= 0.995;

        particle.position.x += particle.velocity.x * dt;
        particle.position.y += particle.velocity.y * dt;

        if (particle.life <= 0 || Math.hypot(particle.position.x, particle.position.y) > system.separation * 3) {
          resetParticle(particle);
        }
      });
    }

    function drawBackground() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.35)";
      ctx.fillRect(0, 0, state.width, state.height);

      ctx.save();
      ctx.translate(state.width / 2, state.height / 2);
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = "#1e1e33";
      ctx.lineWidth = 1;
      for (let r = 120; r < 520; r += 80) {
        ctx.beginPath();
        ctx.arc(0, 0, r + Math.sin(state.time * 0.3) * 5, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawParticles() {
      ctx.save();
      ctx.translate(state.width / 2, state.height / 2);
      particles.forEach((particle) => {
        const speed = Math.hypot(particle.velocity.x, particle.velocity.y) / 4000;
        ctx.strokeStyle = `hsla(${particle.hue}, 90%, 70%, ${Math.min(0.9, 0.3 + speed * 0.4)})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(particle.position.x / metersPerPixel, particle.position.y / metersPerPixel);
        ctx.lineTo(
          (particle.position.x - particle.velocity.x * 2) / metersPerPixel,
          (particle.position.y - particle.velocity.y * 2) / metersPerPixel
        );
        ctx.stroke();
      });
      ctx.restore();
    }

    function drawBlackHole(hole) {
      ctx.save();
      ctx.translate(
        state.width / 2 + hole.position.x / metersPerPixel,
        state.height / 2 + hole.position.y / metersPerPixel
      );
      const gradient = ctx.createRadialGradient(0, 0, hole.radius * 0.2, 0, 0, hole.radius * 3.4);
      gradient.addColorStop(0, "rgba(0, 0, 0, 1)");
      gradient.addColorStop(0.4, "rgba(10, 10, 20, 0.9)");
      gradient.addColorStop(1, "rgba(80, 120, 255, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, hole.radius * 3.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = hole.color;
      ctx.beginPath();
      ctx.arc(0, 0, hole.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, hole.radius * 1.3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    function drawWavefronts() {
      ctx.save();
      ctx.translate(state.width / 2, state.height / 2);
      const phase = (state.time * 0.7) % 1;
      for (let i = 0; i < 4; i += 1) {
        const radius = 80 + (phase + i * 0.25) * 420;
        ctx.strokeStyle = `rgba(120, 140, 255, ${0.25 - i * 0.04})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function tick(timestamp) {
      if (!state.lastTimestamp) {
        state.lastTimestamp = timestamp;
      }
      const delta = (timestamp - state.lastTimestamp) / 1000;
      const dt = Math.min(0.03, delta || 0.016);
      state.lastTimestamp = timestamp;
      state.time = timestamp / 1000;

      updateBinary(dt);
      integrateParticles(dt);

      drawBackground();
      drawWavefronts();
      drawParticles();
      blackHoles.forEach(drawBlackHole);

      requestAnimationFrame(tick);
    }

    window.addEventListener("resize", () => {
      resize();
    });

    resize();
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, state.width, state.height);
    requestAnimationFrame(tick);
  </script>
</body>
</html>
